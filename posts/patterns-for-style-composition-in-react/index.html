<!DOCTYPE html><html><head><meta charset="utf-8"/><title>Patterns for Style Composition in React | Writing</title><meta name="description" content="While React is extremely flexible in terms of how you can structure your application’s UI,
I’ve found that a few patterns for style composition have helped me keep things
organized and easy to work with.
These aren’t hard-and-fast rules, these are simply reflections on how I’ve come to organize components in apps that I’ve worked on."/><meta name="author" content="Brent Jackson"/><meta name="keywords" content="blog,writing,design,minimalism"/><meta name="viewport" content="width=device-width, initial-scale=1"/><style>
* { box-sizing: border-box }

html {
  font-size: 20px;
}

body {
  font-family:
    Athelas,
    Georgia,
    serif;
  line-height: 1.625;
  margin: 0;
  color: #311;
  background-color: #fff;
}

img {
  max-width: 100%;
  height: auto;
}

a {
  color: inherit;
  text-decoration: none;
  background-repeat: no-repeat;
  background-position: bottom;
  background-size: 100% 6px;
  background-image: linear-gradient(transparent, transparent 5px, #ccc 5px, #ccc);
}

a:hover {
  background-image: linear-gradient(transparent, transparent 4px, #0cf 4px, #0cf);
}

h1 a,
h2 a,
h3 a,
h4 a,
h5 a,
h6 a {
  color: inherit;
  text-decoration: none;
  background: none;
}

h1 a:hover,
h2 a:hover,
h3 a:hover,
h4 a:hover,
h5 a:hover,
h6 a:hover {
  background-repeat: no-repeat;
  background-position: bottom;
  background-size: 100% 6px;
  background-image: linear-gradient(transparent, transparent 4px, #0cf 4px, #0cf);
}

h3,
h4, h5, h6 {
  font-size: 1rem;
}

h1, .f1 {
  text-transform: uppercase;
  letter-spacing: .2em;
  font-size: .7rem;
  font-size: .8rem;
  font-style: normal;
  font-weight: 600;
  margin-top: 4rem;
  margin-bottom: 3rem;
}

h2, .f2 {
  font-size: 1rem;
  font-weight: normal;
  font-weight: 500;
  font-style: italic;
  text-transform: none;
  letter-spacing: normal;
  margin-top: 3rem;
  margin-bottom: 1rem;
}

h3, h4, h5 {
  margin-top: 2rem;
  margin-bottom: 1rem;
}

abbr,
.sc {
  text-transform: uppercase;
  letter-spacing: .2em;
  font-size: .7rem;
  font-weight: 600;
}

p, dl, ol, ul, blockquote {
  margin-top: 1rem;
  margin-bottom: 1rem;
}

blockquote {
  font-style: italic;
  margin-left: 2rem;
  margin-right: 2rem;
}


code, pre, samp {
  font-family: 'Roboto Mono', monospace;
  font-size: 80%;
}

pre {
  padding-left: 1rem;
  margin-top: 2rem;
  margin-bottom: 2rem;
  overflow-x: scroll;
  border-left: 4px solid rgba(0, 0, 0, .0625);
}

code {
  background-size: 100% 6px;
  background-repeat: no-repeat;
  background-position: bottom;
  background-image: linear-gradient(transparent, transparent 4px, #ccc 4px);
}

table {
  width: 100%;
  max-width: 100%;
  margin-top: 2rem;
  margin-bottom: 2rem;
  border-collapse: separate;
  border-spacing: 0;
}

th, td {
  padding: 0;
  line-height: 2rem;
}

th {
  font-size: .7rem;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: .2em;
  text-align: left;
  border-bottom: 2px solid;
}

td {
  border-bottom: 1px solid rgba(0, 0, 0, .0625);
}

tr:last-child td {
  border: 0;
}

.link-block {
  display: inline-block;
  text-decoration: none;
  background-image: none;
}

.link-block:hover {
  background-image: none;
}

.measure { max-width: 38em }

.italic { font-style: italic }

.blue { color: #0cf }

</style><style>/* Basscss Layout */

.inline       { display: inline }

.block        { display: block }

.inline-block { display: inline-block }

.table        { display: table }

.table-cell   { display: table-cell }

.overflow-hidden { overflow: hidden }

.overflow-scroll { overflow: scroll }

.overflow-auto   { overflow: auto }

.clearfix:before,
.clearfix:after {
  content: " ";
  display: table
}

.clearfix:after { clear: both }

.left  { float: left }

.right { float: right }

.fit { max-width: 100% }

.max-width-1 { max-width: 24rem }

.max-width-2 { max-width: 32rem }

.max-width-3 { max-width: 48rem }

.max-width-4 { max-width: 64rem }

.border-box { box-sizing: border-box }

</style><style>/* Basscss Margin */

.m0  { margin:        0 }

.mt0 { margin-top:    0 }

.mr0 { margin-right:  0 }

.mb0 { margin-bottom: 0 }

.ml0 { margin-left:   0 }

.mx0 { margin-left:   0; margin-right:  0 }

.my0 { margin-top:    0; margin-bottom: 0 }

.m1  { margin:        .5rem }

.mt1 { margin-top:        .5rem }

.mr1 { margin-right:        .5rem }

.mb1 { margin-bottom:        .5rem }

.ml1 { margin-left:        .5rem }

.mx1 { margin-left:        .5rem; margin-right:        .5rem }

.my1 { margin-top:        .5rem; margin-bottom:        .5rem }

.m2  { margin:        1rem }

.mt2 { margin-top:        1rem }

.mr2 { margin-right:        1rem }

.mb2 { margin-bottom:        1rem }

.ml2 { margin-left:        1rem }

.mx2 { margin-left:        1rem; margin-right:        1rem }

.my2 { margin-top:        1rem; margin-bottom:        1rem }

.m3  { margin:        2rem }

.mt3 { margin-top:        2rem }

.mr3 { margin-right:        2rem }

.mb3 { margin-bottom:        2rem }

.ml3 { margin-left:        2rem }

.mx3 { margin-left:        2rem; margin-right:        2rem }

.my3 { margin-top:        2rem; margin-bottom:        2rem }

.m4  { margin:        4rem }

.mt4 { margin-top:        4rem }

.mr4 { margin-right:        4rem }

.mb4 { margin-bottom:        4rem }

.ml4 { margin-left:        4rem }

.mx4 { margin-left:        4rem; margin-right:        4rem }

.my4 { margin-top:        4rem; margin-bottom:        4rem }

.mxn1 { margin-left:        -.5rem; margin-right:        -.5rem; }

.mxn2 { margin-left:        -1rem; margin-right:        -1rem; }

.mxn3 { margin-left:        -2rem; margin-right:        -2rem; }

.mxn4 { margin-left:        -4rem; margin-right:        -4rem; }

.ml-auto { margin-left: auto }

.mr-auto { margin-right: auto }

.mx-auto { margin-left: auto; margin-right: auto; }

</style><style>/* Basscss Padding */

.p0  { padding: 0 }

.pt0 { padding-top: 0 }

.pr0 { padding-right: 0 }

.pb0 { padding-bottom: 0 }

.pl0 { padding-left: 0 }

.px0 { padding-left: 0; padding-right:  0 }

.py0 { padding-top: 0;  padding-bottom: 0 }

.p1  { padding: .5rem }

.pt1 { padding-top: .5rem }

.pr1 { padding-right: .5rem }

.pb1 { padding-bottom: .5rem }

.pl1 { padding-left: .5rem }

.py1 { padding-top: .5rem; padding-bottom: .5rem }

.px1 { padding-left: .5rem; padding-right: .5rem }

.p2  { padding: 1rem }

.pt2 { padding-top: 1rem }

.pr2 { padding-right: 1rem }

.pb2 { padding-bottom: 1rem }

.pl2 { padding-left: 1rem }

.py2 { padding-top: 1rem; padding-bottom: 1rem }

.px2 { padding-left: 1rem; padding-right: 1rem }

.p3  { padding: 2rem }

.pt3 { padding-top: 2rem }

.pr3 { padding-right: 2rem }

.pb3 { padding-bottom: 2rem }

.pl3 { padding-left: 2rem }

.py3 { padding-top: 2rem; padding-bottom: 2rem }

.px3 { padding-left: 2rem; padding-right: 2rem }

.p4  { padding: 4rem }

.pt4 { padding-top: 4rem }

.pr4 { padding-right: 4rem }

.pb4 { padding-bottom: 4rem }

.pl4 { padding-left: 4rem }

.py4 { padding-top: 4rem; padding-bottom: 4rem }

.px4 { padding-left: 4rem; padding-right: 4rem }

</style><link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400" rel="stylesheet"/></head><body class="measure mx-auto px3"><header><h1 class="f2"><a href="/writing">Jxnblk / Writing</a></h1><h2 class="f1">Patterns for Style Composition in React</h2><div class="sc">Wed Aug 03 2016</div></header><div class=""><div class="py2 mb2" style="color:tomato;">This is a draft post and may not be final.</div><div class="mb4"><!--
What problems does this help solve?
- Maintainability - tracking and updating down styles, deprecating old styles, DRY
- Ease of use - the dream of Bootstrap, but made with "real" code
- Speed up the time it takes to create new views and flows
- Readability - styles are encapsulated at a component-level - shared concerns
- Composability and flexbility - create new styles
-->
<p>While React is extremely flexible in terms of how you can structure your application’s UI,
I’ve found that a few patterns for style composition have helped me keep things
organized and easy to work with.
These aren’t hard-and-fast rules, these are simply reflections on how I’ve come to organize components in apps that I’ve worked on.</p>
<p>I won’t get into approaches for state management or handling the business logic of your app,
instead I’ll be focusing primarily on the visible and interactive parts of the UI.</p>
<h2 id="stateless-functional-ui-components"><a href="#stateless-functional-ui-components">Stateless Functional UI Components</a></h2><p>Generally, I like to keep styles separated from the parts of the app that are tied to state.
That means routes, views, containers, forms, layouts, etc. should not have any styling or classes in them.
Instead, these heavy-lifting components should be composed of primarily stateless functional UI components,
sometimes referred to as <em>presentational</em> components.</p>
<p>For example, a form component render function might look something like this:</p>
<pre>&lt;form onSubmit={<span class="hljs-keyword">this</span>.handleSubmit}&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">Heading</span> <span class="hljs-attribute">children</span>=<span class="hljs-value">'Sign In'</span> /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">Input</span>
    <span class="hljs-attribute">name</span>=<span class="hljs-value">'username'</span>
    <span class="hljs-attribute">value</span>=<span class="hljs-value">{username}</span>
    <span class="hljs-attribute">onChange</span>=<span class="hljs-value">{this.handleChange}</span> /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">Input</span>
    <span class="hljs-attribute">type</span>=<span class="hljs-value">'password'</span>
    <span class="hljs-attribute">name</span>=<span class="hljs-value">'password'</span>
    <span class="hljs-attribute">value</span>=<span class="hljs-value">{password}</span>
    <span class="hljs-attribute">onChange</span>=<span class="hljs-value">{this.handleChange}</span> /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">ButtonPrimary</span>
    <span class="hljs-attribute">type</span>=<span class="hljs-value">'submit'</span>
    <span class="hljs-attribute">children</span>=<span class="hljs-value">'Sign In'</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">form</span>&gt;</span></span></pre><p>Notice how none of the elements have a <code>className</code> or <code>style</code> prop.
Using <code>className</code> or <code>style</code> props at this level <em>could</em> be considered a code smell.
Each UI component used here encapsulates its own styling,
and the styling simply becomes an implementation detail.</p>
<p>An example Button component might look something like the following:</p>
<pre><span class="hljs-keyword">const</span> Button = ({
  ...props
}) =&gt; {
  <span class="hljs-keyword">const</span> sx = {
    fontFamily: <span class="hljs-string">'inherit'</span>,
    fontSize: <span class="hljs-string">'inherit'</span>,
    fontWeight: <span class="hljs-string">'bold'</span>,
    textDecoration: <span class="hljs-string">'none'</span>,
    display: <span class="hljs-string">'inline-block'</span>,
    margin: <span class="hljs-number">0</span>,
    paddingTop: <span class="hljs-number">8</span>,
    paddingBottom: <span class="hljs-number">8</span>,
    paddingLeft: <span class="hljs-number">16</span>,
    paddingRight: <span class="hljs-number">16</span>,
    border: <span class="hljs-number">0</span>,
    color: <span class="hljs-string">'white'</span>,
    backgroundColor: <span class="hljs-string">'blue'</span>,
    WebkitAppearance: <span class="hljs-string">'none'</span>,
    MozAppearance: <span class="hljs-string">'none'</span>
  }

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">button</span> {<span class="hljs-attribute">...props</span>} <span class="hljs-attribute">style</span>=<span class="hljs-value">{sx}</span> /&gt;</span>
  )</span>
}</pre><p>I’ve used inline styles here for readability and to help demonstrate how this works,
but any CSS-in-JS solution can be used instead and won’t have any affect on the form component above.
By keeping all styling encapsulated in this component,
the rest of the application doesn’t need to know anything about the Button beyond its props API.</p>
<h2 id="styles-module"><a href="#styles-module">Styles Module</a></h2><p>You may have noticed that a few property values were hard-coded into the Button example.
Generally, I wouldn’t recommend hard-coding things in like that.
Any values that are likely to be used across different UI components should be split into their own module.</p>
<p>Here is a simple example module to start with:</p>
<pre><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> white = <span class="hljs-string">'#fff'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> black = <span class="hljs-string">'#111'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> blue = <span class="hljs-string">'#07c'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> colors = {
  white,
  black,
  blue
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> space = [
  <span class="hljs-number">0</span>,
  <span class="hljs-number">8</span>,
  <span class="hljs-number">16</span>,
  <span class="hljs-number">32</span>,
  <span class="hljs-number">64</span>
]

<span class="hljs-keyword">const</span> styles = {
  bold: <span class="hljs-number">600</span>,
  space,
  colors
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> styles</pre><p>And here is what the updated Button component could look like:</p>
<pre><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> { bold, space, colors } <span class="hljs-keyword">from</span> <span class="hljs-string">'./styles'</span>

const Button = ({
  ...props
}) =&gt; {
  const sx = {
    fontFamily: <span class="hljs-string">'inherit'</span>,
    fontSize: <span class="hljs-string">'inherit'</span>,
    fontWeight: bold,
    textDecoration: <span class="hljs-string">'none'</span>,
    display: <span class="hljs-string">'inline-block'</span>,
    margin: 0,
    paddingTop: space[1],
    paddingBottom: space[1],
    paddingLeft: space[2],
    paddingRight: space[2],
    border: 0,
    color: colors.white,
    backgroundColor: colors.blue,
    WebkitAppearance: <span class="hljs-string">'none'</span>,
    MozAppearance: <span class="hljs-string">'none'</span>
  }

  return (
    &lt;button {...props} style={sx} /&gt;
  )
}</pre><p>The style object could store anything related to styling that is shared across components,
including borders, border radii, shadows, animation duration, etc.</p>
<p>You could even export more elaborate combinations of styles like the following:</p>
<pre><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> cardStyle = {
  backgroundColor: white,
  borderRadius: <span class="hljs-number">3</span>,
  boxShadow: <span class="hljs-string">`0 0 4px <span class="hljs-subst">${shade[1]}</span>`</span>
}</pre><p>But I’d recommend delegating combinations like these to components and using composition instead, as I’ll show below.</p>
<h2 id="style-functions"><a href="#style-functions">Style Functions</a></h2><p>Since we’re using JavaScript, we can also employ helper functions for styling elements.
For example, a function to create <code>rgba</code> values of black can be very handy.</p>
<pre><span class="hljs-keyword">const</span> darken = (n) =&gt; <span class="hljs-string">`rgba(0, 0, 0, <span class="hljs-subst">${n}</span>)`</span>

darken(<span class="hljs-number">1</span> / <span class="hljs-number">8</span>) <span class="hljs-comment">// 'rgba(0, 0, 0, 0.125)'</span></pre><p>Functions like this can then be used to create a value scale array to help keep things consistent.</p>
<pre><span class="hljs-keyword">const</span> shade = [
  darken(<span class="hljs-number">0</span>),
  darken(<span class="hljs-number">1</span> / <span class="hljs-number">8</span>),
  darken(<span class="hljs-number">1</span> / <span class="hljs-number">4</span>),
  darken(<span class="hljs-number">3</span> / <span class="hljs-number">8</span>),
  darken(<span class="hljs-number">1</span> / <span class="hljs-number">2</span>),
  darken(<span class="hljs-number">5</span> / <span class="hljs-number">8</span>),
  darken(<span class="hljs-number">3</span> / <span class="hljs-number">4</span>),
  darken(<span class="hljs-number">7</span> / <span class="hljs-number">8</span>),
  darken(<span class="hljs-number">1</span>)
]

shade[<span class="hljs-number">4</span>] <span class="hljs-comment">// 'rgba(0, 0, 0, 0.5)'</span></pre><p>Another example would be creating a scale for margin and padding to help keep visual rhythm consistent.</p>
<pre><span class="hljs-comment">// Modular powers of two scale</span>
<span class="hljs-keyword">const</span> scale = [
  <span class="hljs-number">0</span>,
  <span class="hljs-number">8</span>,
  <span class="hljs-number">16</span>,
  <span class="hljs-number">32</span>,
  <span class="hljs-number">64</span>
]

<span class="hljs-comment">// Functions to get partial style objects</span>
<span class="hljs-keyword">const</span> createScaledPropertyGetter = (scale) =&gt; (prop) =&gt; (x) =&gt; {
  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">'number'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> scale[x] === <span class="hljs-string">'number'</span>)
    ? { [prop]: scale[x] }
    : <span class="hljs-literal">null</span>
}
<span class="hljs-keyword">const</span> getScaledProperty = createScaledPropertyGetter(scale)

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getMargin = getScaledProperty(<span class="hljs-string">'margin'</span>)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getPadding = getScaledProperty(<span class="hljs-string">'padding'</span>)</pre><pre><span class="hljs-comment">// Style function usage</span>
<span class="hljs-keyword">const</span> Box = ({
  m,
  p,
  ...props
}) =&gt; {
  <span class="hljs-keyword">const</span> sx = {
    ...getMargin(m),
    ...getPadding(p)
  }

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> {<span class="hljs-attribute">...props</span>} <span class="hljs-attribute">style</span>=<span class="hljs-value">{sx}</span> /&gt;</span>
}</span></pre><pre><span class="hljs-comment">// Component usage</span>
&lt;div&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">Box</span> <span class="hljs-attribute">m</span>=<span class="hljs-value">{2}</span> <span class="hljs-attribute">p</span>=<span class="hljs-value">{3}</span>&gt;</span>
    A box with 16px margin and 32px padding
  <span class="hljs-tag">&lt;/<span class="hljs-title">Box</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span></span></pre><h2 id="npm-modules"><a href="#npm-modules">Npm Modules</a></h2><p>While the rgba color function above is a fairly simple one,
sometimes more complex color transformations can be helpful when creating UI.
Well, we’re in luck, because we can use literally anything on <a href="https://npmjs.com">npm</a>.</p>
<p>Instead of the <code>darken</code> function above, here is an example using <a href="https://www.npmjs.com/package/chroma-js"><code>chroma-js</code></a>’s <code>alpha</code> function.</p>
<pre><span class="hljs-keyword">import</span> chroma <span class="hljs-keyword">from</span> <span class="hljs-string">'chroma-js'</span>

const alpha = (color) =&gt; (a) =&gt; chroma(color).alpha(a).css()

const darken = alpha(<span class="hljs-string">'#000'</span>)

const shade = [
  darken(0),
  darken(1 / 8),
  darken(1 / 4),
  // ...
]</pre><p>Using chroma, this function can work with any color from the style object.</p>
<pre><span class="hljs-keyword">const</span> blueAlpha = [
  alpha(blue)(<span class="hljs-number">0</span>),
  alpha(blue)(<span class="hljs-number">1</span> / <span class="hljs-number">4</span>),
  alpha(blue)(<span class="hljs-number">1</span> / <span class="hljs-number">2</span>),
  alpha(blue)(<span class="hljs-number">3</span> / <span class="hljs-number">4</span>),
  alpha(blue)(<span class="hljs-number">1</span>)
]</pre><h2 id="base-component"><a href="#base-component">Base Component</a></h2><p>Beyond just importing style values, there is a tremendous amount of flexibility when it comes to component
composition when using React, since components are essentially just functions.
Take the Button component from above, and we’ll change some of the style details to props to make it more reusable.</p>
<pre><span class="hljs-keyword">const</span> Button = ({
  big,
  color = colors.white,
  backgroundColor = colors.blue,
  ...props
}) =&gt; {
  <span class="hljs-keyword">const</span> sx = {
    fontFamily: <span class="hljs-string">'inherit'</span>,
    fontSize: <span class="hljs-string">'inherit'</span>,
    fontWeight: bold,
    textDecoration: <span class="hljs-string">'none'</span>,
    display: <span class="hljs-string">'inline-block'</span>,
    margin: <span class="hljs-number">0</span>,
    paddingTop: big ? space[<span class="hljs-number">2</span>] : space[<span class="hljs-number">1</span>],
    paddingBottom: big ? space[<span class="hljs-number">2</span>] : space[<span class="hljs-number">1</span>],
    paddingLeft: space[<span class="hljs-number">2</span>],
    paddingRight: space[<span class="hljs-number">2</span>],
    border: <span class="hljs-number">0</span>,
    color,
    backgroundColor,
    WebkitAppearance: <span class="hljs-string">'none'</span>,
    MozAppearance: <span class="hljs-string">'none'</span>
  }

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">button</span> {<span class="hljs-attribute">...props</span>} <span class="hljs-attribute">style</span>=<span class="hljs-value">{sx}</span> /&gt;</span>
  )</span>
}</pre><p>The <code>color</code> and <code>backgroundColor</code> properties have been moved up to the component’s props.
Additionally, we’ve added a <code>big</code> prop to adjust the padding top and bottom.</p>
<p>Now this component is fine by itself, but what if we want a secondary button style?
Doing the following would become tedious and error prone very quickly:</p>
<pre>&lt;Button
  color={colors.black}
  backgroundColor={colors.lightblue}
  children=<span class="hljs-string">'Secondary Button'</span> /&gt;</pre><p>Instead, we can create a dedicated secondary button component.</p>
<pre><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> Button <span class="hljs-keyword">from</span> <span class="hljs-string">'./Button'</span>

const ButtonSecondary = (props) =&gt; (
  &lt;Button
    {...props}
    color={colors.black}
    backgroundColor={colors.lightblue} /&gt;
)</pre><p>By adjusting the props API of the base Button component, an entire set of button styles can be created.</p>
<pre><span class="hljs-keyword">const</span> ButtonBig = (props) =&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">Button</span> {<span class="hljs-attribute">...props</span>} <span class="hljs-attribute">big</span> /&gt;</span>
const ButtonGreen = (props) =&gt; <span class="hljs-tag">&lt;<span class="hljs-title">Button</span> {<span class="hljs-attribute">...props</span>} <span class="hljs-attribute">backgroundColor</span>=<span class="hljs-value">{colors.green}</span> /&gt;</span>
const ButtonRed = (props) =&gt; <span class="hljs-tag">&lt;<span class="hljs-title">Button</span> {<span class="hljs-attribute">...props</span>} <span class="hljs-attribute">backgroundColor</span>=<span class="hljs-value">{colors.red}</span> /&gt;</span>
const ButtonOutline = (props) =&gt; <span class="hljs-tag">&lt;<span class="hljs-title">Button</span> {<span class="hljs-attribute">...props</span>} <span class="hljs-attribute">outline</span> /&gt;</span></span></pre><p>This pattern lends itself well to layout components as well.
Assume we have a generic Box component that accepts props for various layout styles.
This base layout component can then be used to create grid system components and other primitives.</p>
<pre><span class="hljs-keyword">const</span> Grid = (props) =&gt; (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">Box</span> {<span class="hljs-attribute">...props</span>}
    <span class="hljs-attribute">display</span>=<span class="hljs-value">'inline-block'</span>
    <span class="hljs-attribute">verticalAlign</span>=<span class="hljs-value">'top'</span>
    <span class="hljs-attribute">px</span>=<span class="hljs-value">{2}</span> /&gt;</span>
)</span>

<span class="hljs-keyword">const</span> Half = (props) =&gt; (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">Grid</span> {<span class="hljs-attribute">...props</span>}
    <span class="hljs-attribute">width</span>=<span class="hljs-value">{1</span> / <span class="hljs-attribute">2</span>} /&gt;</span>
)</span>

<span class="hljs-keyword">const</span> Third = (props) =&gt; (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">Grid</span> {<span class="hljs-attribute">...props</span>}
    <span class="hljs-attribute">width</span>=<span class="hljs-value">{1</span> / <span class="hljs-attribute">3</span>} /&gt;</span>
)</span>

<span class="hljs-keyword">const</span> Quarter = (props) =&gt; (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">Grid</span> {<span class="hljs-attribute">...props</span>}
    <span class="hljs-attribute">width</span>=<span class="hljs-value">{1</span> / <span class="hljs-attribute">4</span>} /&gt;</span>
)</span>

<span class="hljs-keyword">const</span> Flex = (props) =&gt; (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">Box</span> {<span class="hljs-attribute">...props</span>}
    <span class="hljs-attribute">display</span>=<span class="hljs-value">'flex'</span> /&gt;</span>
)</span>

<span class="hljs-keyword">const</span> FlexAuto = (props) =&gt; (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">Box</span> {<span class="hljs-attribute">...props</span>}
    <span class="hljs-attribute">flex</span>=<span class="hljs-value">'1 1 auto'</span> /&gt;</span>
)</span></pre><p>Typography styles are another great candidate for building up with composition.
By using a base typographic component, you can help ensure consistency and keep your styling DRY in a component-based architecture.</p>
<pre><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> { alternateFont, typeScale, boldFontWeight } <span class="hljs-keyword">from</span> <span class="hljs-string">'./styles'</span>

const Text = ({
  tag = <span class="hljs-string">'span'</span>,
  size = 4,
  alt,
  center,
  bold,
  caps,
  ...props
}) =&gt; {
  const Tag = tag
  const sx = {
    fontFamily: alt ? alternateFont : null,
    fontSize: typeScale[size],
    fontWeight: bold ? boldFontWeight : null,
    textAlign: center ? <span class="hljs-string">'center'</span> : null,
    textTransform: caps ? <span class="hljs-string">'uppercase'</span> : null
  }

  return &lt;Tag {...props} style={sx} /&gt;
}</pre><pre><span class="hljs-keyword">const</span> LeadText = (props) =&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">Text</span> {<span class="hljs-attribute">...props</span>} <span class="hljs-attribute">size</span>=<span class="hljs-value">{3}</span> /&gt;</span>
const Caps = (props) =&gt; <span class="hljs-tag">&lt;<span class="hljs-title">Text</span> {<span class="hljs-attribute">...props</span>} <span class="hljs-attribute">caps</span> /&gt;</span>
const MetaText = (props) =&gt; <span class="hljs-tag">&lt;<span class="hljs-title">Text</span> {<span class="hljs-attribute">...props</span>} <span class="hljs-attribute">size</span>=<span class="hljs-value">{5}</span> <span class="hljs-attribute">caps</span> /&gt;</span>
const AltParagraph = (props) =&gt; <span class="hljs-tag">&lt;<span class="hljs-title">Text</span> {<span class="hljs-attribute">...props</span>} <span class="hljs-attribute">tag</span>=<span class="hljs-value">'p'</span> <span class="hljs-attribute">alt</span> /&gt;</span>

const CapsButton = ({ children, ...props }) =&gt; (
  <span class="hljs-tag">&lt;<span class="hljs-title">Button</span> {<span class="hljs-attribute">...props</span>}&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">Caps</span>&gt;</span>
      {children}
    <span class="hljs-tag">&lt;/<span class="hljs-title">Caps</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">Button</span>&gt;</span>
)</span></pre><p>Keep in mind, that these components are just a few examples and your needs will vary greatly on an app-by-app basis.</p>
<h2 id="higher-order-components"><a href="#higher-order-components">Higher Order Components</a></h2><p>I&#39;m generally a fan of keeping most of an applications state at the top level of a React tree,
often using something like <a href="https://github.com/reactjs/redux">Redux</a>.
However, sometimes there are isolated UI components that only require a minimal amount of state for interaction,
and using them as standalone components is sufficient.</p>
<p>One example of this is a carousel<a href="#*">*</a>, where the state of the current slide generally doesn’t need to persist across page views.
Instead of combining the state of the carousel with its UI, we can create a higher order component for better reusability.
The higher order component will have a current slide index, accept a length prop, and have methods for setting position.</p>
<pre><span class="hljs-comment">// Higher order component</span>
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>

// This could be named something more generic like Counter or Cycle
const CarouselContainer = (Comp) =&gt; {
  class Carousel extends React.Component {
    constructor () {
      super()
      this.state = {
        index: 0
      }
      this.previous = () =&gt; {
        const { index } = this.state
        if (index &gt; 0) {
          this.setState({ index: index - 1})
        }
      }

      this.next = () =&gt; {
        const { length = Infinity } = this.props
        const { index } = this.state
        if (index &lt; length - 1) {
          this.setState({ index: index + 1 })
        }
      }
    }

    render () {
      const props = { ...this.props }
      delete props.length

      return (
        &lt;Comp
          {...props}
          {...this.state}
          previous={this.previous}
          next={this.next} /&gt;
      )
    }
  }

  return Carousel
}

export default CarouselContainer</pre><p>Using a higher order component we can create a carousel from any number of UI elements.
For example, a simple carousel may have only previous and next buttons,
while a more complex one might include image thumbnails of each slide across the bottom.
Both of these can use the same hoc to handle their state.</p>
<pre><span class="hljs-comment">// UI component</span>
<span class="hljs-keyword">const</span> Carousel = ({ index, ...props }) =&gt; {
  <span class="hljs-keyword">const</span> length = props.length || props.children.length || <span class="hljs-number">0</span>

  <span class="hljs-keyword">const</span> sx = {
    root: {
      overflow: <span class="hljs-string">'hidden'</span>
    },
    inner: {
      whiteSpace: <span class="hljs-string">'nowrap'</span>,
      height: <span class="hljs-string">'100%'</span>,
      transition: <span class="hljs-string">'transform .2s ease-out'</span>,
      transform: <span class="hljs-string">`translateX(<span class="hljs-subst">${index % length * -100}</span>%)`</span>
    },
    child: {
      display: <span class="hljs-string">'inline-block'</span>,
      verticalAlign: <span class="hljs-string">'middle'</span>,
      whiteSpace: <span class="hljs-string">'normal'</span>,
      outline: <span class="hljs-string">'1px solid red'</span>,
      width: <span class="hljs-string">'100%'</span>,
      height: <span class="hljs-string">'100%'</span>
    }
  }

  <span class="hljs-keyword">const</span> children = React.Children.map(props.children, (child, i) =&gt; {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">style</span>=<span class="hljs-value">{sx.child}</span>&gt;</span>
        {child}
      <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    )</span>
  })

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">style</span>=<span class="hljs-value">{sx.root}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">style</span>=<span class="hljs-value">{sx.inner}</span>&gt;</span>
        {children}
      <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
  )</span>
}</pre><pre><span class="hljs-comment">// Final Carousel component</span>
<span class="hljs-keyword">const</span> HeroCarousel = (props) =&gt; {
    <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">Carousel</span> <span class="hljs-attribute">index</span>=<span class="hljs-value">{props.index}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>Slide one<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>Slide two<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>Slide three<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-title">Carousel</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">Button</span>
        <span class="hljs-attribute">onClick</span>=<span class="hljs-value">{props.previous}</span>
        <span class="hljs-attribute">children</span>=<span class="hljs-value">'Previous'</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">Button</span>
        <span class="hljs-attribute">onClick</span>=<span class="hljs-value">{props.next}</span>
        <span class="hljs-attribute">children</span>=<span class="hljs-value">'Next'</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    )</span>
}

<span class="hljs-comment">// Wrap the component with the functionality from the higher-order component</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> CarouselContainer(HeroCarousel)</pre><p>By keeping the styling separate from the interactive state,
any number of carousel variations can be created from these reusable parts.</p>
<p>Just like the base component pattern above, higher order components
can work well for styling layout, typography and colors.
This is the pattern used in <a href="https://github.com/jxnblk/reflexbox">Reflexbox</a>,
and similar to Rebass’s <a href="https://github.com/jxnblk/rebass/blob/master/src/Base.js">Base component</a>.</p>
<h2 id="a-note-about-performance"><a href="#a-note-about-performance">A Note About Performance</a></h2><p>While there are many different ways to handle styling in a component-based app,
make sure to pay close attention to the size of your bundle.
It can be very easy to create the wrong abstractions and end up with needless bloat.
Some of the patterns in this article, when taken to their logical extreme,
could actually harm the performance and create a degraded experience for your end users.</p>
<p>Everything you do should be for the user’s benefit, not your own.</p>
<h2 id="related"><a href="#related">Related</a></h2><ul>
<li><a href="http://rauchg.com/2015/pure-ui/">Pure UI</a> by Guillermo Rauch</li>
<li><a href="http://jxnblk.com/reflexbox">Reflexbox</a></li>
<li><a href="http://jxnblk.com/rebass">Rebass</a></li>
<li><a href="https://github.com/jxnblk/robox">Robox</a></li>
<li><a href="https://github.com/jxnblk/understyle">Understyle</a></li>
</ul>
<p><small id='*'>Please don’t use carousels in your app. Users hate them.</small></p>
<!--
  - Toggle example
-->
</div><noscript></noscript><div class="inline-block"><a href="https://twitter.com/share" class="twitter-share-button" data-text="Patterns for Style Composition in React" data-via="jxnblk" data-size="large">Tweet</a><script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?"http":"https";if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document, "script", "twitter-wjs");</script></div><p>Questions, Comments, Suggestions? <a href="https://github.com/jxnblk/writing/issues/new?title=Patterns for Style Composition in React" target="_blank">Open an Issue</a></p><noscript></noscript></div><footer class="sc py4"><a href="/">Made by Jxnblk</a></footer><script>(function(i,s,o,g,r,a,m){i["GoogleAnalyticsObject"]=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,"script","//www.google-analytics.com/analytics.js","ga"); ga("create", "UA-4603832-6", "auto"); ga("send", "pageview");</script></body></html>