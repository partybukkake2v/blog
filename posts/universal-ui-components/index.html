<!DOCTYPE html><html><head><meta charset="utf-8"/><title>Universal UI Components | Writing</title><meta name="description" content="For a while now, I’ve been interested in the idea of creating portable,
interoperable functional UI components that can work in any DOM rendering library,
whether it’s
React,
Preact,
hyperscript,
bel,
yo-yo,
or some other library."/><meta name="author" content="Brent Jackson"/><meta name="keywords" content="blog,writing,design,minimalism"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="twitter:card" content="summary"/><meta name="twitter:creator" content="@jxnblk"/><meta name="twitter:title" content="Universal UI Components"/><meta name="twitter:description" content="For a while now, I’ve been interested in the idea of creating portable,
interoperable functional UI components that can work in any DOM rendering library,
whether it’s
React,
Preact,
hyperscript,
bel,
yo-yo,
or some other library."/><meta name="twitter:image" content="http://jxnblk.com/avatar/avatar-640.png"/><style>
* { box-sizing: border-box }

html {
  font-size: 20px;
}

body {
  font-family:
    Athelas,
    Georgia,
    serif;
  line-height: 1.625;
  margin: 0;
  color: #311;
  background-color: #fff;
}

img {
  max-width: 100%;
  height: auto;
}

a {
  color: inherit;
  text-decoration: none;
  background-repeat: no-repeat;
  background-position: bottom;
  background-size: 100% 6px;
  background-image: linear-gradient(transparent, transparent 5px, #ccc 5px, #ccc);
}

a:hover {
  background-image: linear-gradient(transparent, transparent 4px, #0cf 4px, #0cf);
}

h1 a,
h2 a,
h3 a,
h4 a,
h5 a,
h6 a {
  color: inherit;
  text-decoration: none;
  background: none;
}

h1 a:hover,
h2 a:hover,
h3 a:hover,
h4 a:hover,
h5 a:hover,
h6 a:hover {
  background-repeat: no-repeat;
  background-position: bottom;
  background-size: 100% 6px;
  background-image: linear-gradient(transparent, transparent 4px, #0cf 4px, #0cf);
}

h3,
h4, h5, h6 {
  font-size: 1rem;
}

h1, .f1 {
  text-transform: uppercase;
  letter-spacing: .2em;
  font-size: .7rem;
  font-size: .8rem;
  font-style: normal;
  font-weight: 600;
  margin-top: 4rem;
  margin-bottom: 3rem;
}

h2, .f2 {
  font-size: 1rem;
  font-weight: normal;
  font-weight: 700;
  text-transform: none;
  letter-spacing: normal;
  margin-top: 3rem;
  margin-bottom: 1rem;
}

h3, .f3 {
  font-weight: 400;
  font-style: italic;
}

h3, h4, h5 {
  margin-top: 2rem;
  margin-bottom: 1rem;
}

abbr,
.sc {
  text-transform: uppercase;
  letter-spacing: .2em;
  font-size: .7rem;
  font-weight: 600;
}

p, dl, ol, ul, blockquote {
  margin-top: 1rem;
  margin-bottom: 1rem;
}

blockquote {
  font-style: italic;
  margin-left: 2rem;
  margin-right: 2rem;
}


code, pre, samp {
  font-family: 'Roboto Mono', monospace;
}

pre {
  font-size: 70%;
  padding-left: 1rem;
  margin-top: 2rem;
  margin-bottom: 2rem;
  overflow-x: scroll;
  border-left: 4px solid rgba(0, 0, 0, .0625);
}

hr {
  border: 0;
  border-bottom: 4px solid rgba(0, 0, 0, .0625);
  margin-top: 2em;
  margin-bottom: 2em;
}

code {
  font-size: 80%;
  background-size: 100% 8px;
  background-repeat: no-repeat;
  background-position: bottom;
  background-image: linear-gradient(transparent 4px, rgba(0, 0, 0, .125) 4px);
}

table {
  width: 100%;
  max-width: 100%;
  margin-top: 2rem;
  margin-bottom: 2rem;
  border-collapse: separate;
  border-spacing: 0;
}

th, td {
  padding: 0;
  line-height: 2rem;
}

th {
  font-size: .7rem;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: .2em;
  text-align: left;
  border-bottom: 2px solid;
}

td {
  border-bottom: 1px solid rgba(0, 0, 0, .0625);
}

tr:last-child td {
  border: 0;
}

.link-block {
  display: inline-block;
  text-decoration: none;
  background-image: none;
}

.link-block:hover {
  background-image: none;
}

.measure { max-width: 38em }

.italic { font-style: italic }

.blue { color: #0cf }

</style><style>/* Basscss Layout */

.inline       { display: inline }

.block        { display: block }

.inline-block { display: inline-block }

.table        { display: table }

.table-cell   { display: table-cell }

.overflow-hidden { overflow: hidden }

.overflow-scroll { overflow: scroll }

.overflow-auto   { overflow: auto }

.clearfix:before,
.clearfix:after {
  content: " ";
  display: table
}

.clearfix:after { clear: both }

.left  { float: left }

.right { float: right }

.fit { max-width: 100% }

.max-width-1 { max-width: 24rem }

.max-width-2 { max-width: 32rem }

.max-width-3 { max-width: 48rem }

.max-width-4 { max-width: 64rem }

.border-box { box-sizing: border-box }

</style><style>/* Basscss Margin */

.m0  { margin:        0 }

.mt0 { margin-top:    0 }

.mr0 { margin-right:  0 }

.mb0 { margin-bottom: 0 }

.ml0 { margin-left:   0 }

.mx0 { margin-left:   0; margin-right:  0 }

.my0 { margin-top:    0; margin-bottom: 0 }

.m1  { margin:        .5rem }

.mt1 { margin-top:        .5rem }

.mr1 { margin-right:        .5rem }

.mb1 { margin-bottom:        .5rem }

.ml1 { margin-left:        .5rem }

.mx1 { margin-left:        .5rem; margin-right:        .5rem }

.my1 { margin-top:        .5rem; margin-bottom:        .5rem }

.m2  { margin:        1rem }

.mt2 { margin-top:        1rem }

.mr2 { margin-right:        1rem }

.mb2 { margin-bottom:        1rem }

.ml2 { margin-left:        1rem }

.mx2 { margin-left:        1rem; margin-right:        1rem }

.my2 { margin-top:        1rem; margin-bottom:        1rem }

.m3  { margin:        2rem }

.mt3 { margin-top:        2rem }

.mr3 { margin-right:        2rem }

.mb3 { margin-bottom:        2rem }

.ml3 { margin-left:        2rem }

.mx3 { margin-left:        2rem; margin-right:        2rem }

.my3 { margin-top:        2rem; margin-bottom:        2rem }

.m4  { margin:        4rem }

.mt4 { margin-top:        4rem }

.mr4 { margin-right:        4rem }

.mb4 { margin-bottom:        4rem }

.ml4 { margin-left:        4rem }

.mx4 { margin-left:        4rem; margin-right:        4rem }

.my4 { margin-top:        4rem; margin-bottom:        4rem }

.mxn1 { margin-left:        -.5rem; margin-right:        -.5rem; }

.mxn2 { margin-left:        -1rem; margin-right:        -1rem; }

.mxn3 { margin-left:        -2rem; margin-right:        -2rem; }

.mxn4 { margin-left:        -4rem; margin-right:        -4rem; }

.ml-auto { margin-left: auto }

.mr-auto { margin-right: auto }

.mx-auto { margin-left: auto; margin-right: auto; }

</style><style>/* Basscss Padding */

.p0  { padding: 0 }

.pt0 { padding-top: 0 }

.pr0 { padding-right: 0 }

.pb0 { padding-bottom: 0 }

.pl0 { padding-left: 0 }

.px0 { padding-left: 0; padding-right:  0 }

.py0 { padding-top: 0;  padding-bottom: 0 }

.p1  { padding: .5rem }

.pt1 { padding-top: .5rem }

.pr1 { padding-right: .5rem }

.pb1 { padding-bottom: .5rem }

.pl1 { padding-left: .5rem }

.py1 { padding-top: .5rem; padding-bottom: .5rem }

.px1 { padding-left: .5rem; padding-right: .5rem }

.p2  { padding: 1rem }

.pt2 { padding-top: 1rem }

.pr2 { padding-right: 1rem }

.pb2 { padding-bottom: 1rem }

.pl2 { padding-left: 1rem }

.py2 { padding-top: 1rem; padding-bottom: 1rem }

.px2 { padding-left: 1rem; padding-right: 1rem }

.p3  { padding: 2rem }

.pt3 { padding-top: 2rem }

.pr3 { padding-right: 2rem }

.pb3 { padding-bottom: 2rem }

.pl3 { padding-left: 2rem }

.py3 { padding-top: 2rem; padding-bottom: 2rem }

.px3 { padding-left: 2rem; padding-right: 2rem }

.p4  { padding: 4rem }

.pt4 { padding-top: 4rem }

.pr4 { padding-right: 4rem }

.pb4 { padding-bottom: 4rem }

.pl4 { padding-left: 4rem }

.py4 { padding-top: 4rem; padding-bottom: 4rem }

.px4 { padding-left: 4rem; padding-right: 4rem }

</style><link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400" rel="stylesheet"/></head><body class="measure mx-auto px2"><header><h1><a href="/writing">Jxnblk Writing</a></h1><h2 class="f1">Universal UI Components</h2><div class="sc">Wednesday, July 6, 2016</div></header><div class=""><div class="mb4"><p>For a while now, I’ve been interested in the idea of creating portable,
interoperable functional UI components that can work in any DOM rendering library,
whether it’s
<a href="https://facebook.github.io/react/">React</a>,
<a href="https://preactjs.com">Preact</a>,
<a href="https://github.com/dominictarr/hyperscript">hyperscript</a>,
<a href="https://github.com/shama/bel">bel</a>,
<a href="https://github.com/maxogden/yo-yo">yo-yo</a>,
or some other library.</p>
<p>The idea of functional UI components is a simple one: pass arguments into a function and it returns a representation of the DOM,
usually with encapsulated styles and interactivity handled with callbacks to a global state, a la Redux.</p>
<p>If you look at the currently available technology, there are predominantly three ways to create these components:</p>
<ul>
<li><a href="https://facebook.github.io/jsx/"><strong>JSX</strong></a> (from React) - uses an XML-like syntax to call functions that return representations of DOM elements</li>
<li><a href="https://github.com/dominictarr/hyperscript"><strong>Hyperscript</strong></a> - similar to JSX, but uses standard JavaScript syntax and function calls</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals"><strong>ES2015 tagged template literals</strong></a> - a new string type introduced to JavaScript</li>
</ul>
<p>Each has its own pros and cons. While JSX is mostly syntactic sugar, some prefer to use standard JavaScript syntax.
One big advantage JSX has is that it abstracts away the function used to create DOM elements.
For example, React uses <code>React.createElement</code> while Preact uses <code>Preact.h</code>.
The pragma used in JSX is configurable by the end user.
Hyperscript, although older than JSX, uses a similar function, but is written in standard JavaScript.
Tagged template literals are also standard JavaScript,
but require a little bit of extra code to change template literals into DOM elements.</p>
<h2 id="the-same-but-different"><a href="#the-same-but-different">The same, but different</a></h2><p>Assuming we pick one of the above syntaxes,
there are relatively few differences among the implementations of components across libraries.
For example, here is a bare-bones Button component for several different libraries.
For brevity, styles have been left out of these examples.</p>
<pre><span class="hljs-comment">// React using JSX</span>
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>

const Button = (props) =&gt; (
  &lt;button {...props} /&gt;
)
export default Button</pre><pre><span class="hljs-comment">// Preact using JSX</span>
<span class="hljs-keyword">import</span> { h } <span class="hljs-keyword">from</span> <span class="hljs-string">'preact'</span>

const Button = (props) =&gt; (
  &lt;button {...props} /&gt;
)
export default Button</pre><pre><span class="hljs-comment">// Hyperscript</span>
<span class="hljs-keyword">import</span> h <span class="hljs-keyword">from</span> <span class="hljs-string">'hyperscript'</span>

const Button = (props) =&gt; (
  h(<span class="hljs-string">'button'</span>, props)
)
export default Button</pre><pre>// yo-yo using tagged template literals
import yo from 'yo-yo'

const Button = ({ text, ...props }) =&gt; (
  yo`&lt;button ${props}&gt;${text}&lt;/button`
)
export default Button</pre><p>There are still quite a few differences in syntax between JSX, hyperscript, and tagged template literals.
For the sake of this post, I’ll focus on implementing these components in JSX.</p>
<p>The first three examples are covered, but here’s what the hyperscript and yo-yo examples would look like in JSX.</p>
<pre><span class="hljs-comment">// Hyperscript with JSX</span>
<span class="hljs-keyword">import</span> h <span class="hljs-keyword">from</span> <span class="hljs-string">'hyperscript'</span>

const Button = (props) =&gt; (
  &lt;button {...props} /&gt;
)
export default Button</pre><pre><span class="hljs-comment">// bel (yo-yo) with JSX</span>
<span class="hljs-comment">// yo-yo uses the bel package to create elements</span>
<span class="hljs-keyword">import</span> { createElement } <span class="hljs-keyword">from</span> <span class="hljs-string">'bel'</span>

const Button = (props) =&gt; (
  &lt;button {...props} /&gt;
)
export default Button</pre><p>For each of the non-React versions, JSX needs to be configured to use the appropriate pragma.
Hyperscript and Preact both name their create element functions <code>h</code>.
Here is an example <code>.babelrc</code> configuration.</p>
<pre>{
  "<span class="hljs-attribute">presets</span>": <span class="hljs-value">[
    <span class="hljs-string">"es2015"</span>,
    <span class="hljs-string">"stage-0"</span>
  ]</span>,
  "<span class="hljs-attribute">plugins</span>": <span class="hljs-value">[
    [
      <span class="hljs-string">"transform-react-jsx"</span>,
      { "<span class="hljs-attribute">pragma</span>": <span class="hljs-value"><span class="hljs-string">"h"</span> </span>}
    ]
  ]
</span>}</pre><p>Although the other libraries name their create element functions differently,
they can all be named <code>h</code> within the components for cross-library compatibility.</p>
<pre><span class="hljs-comment">// React using JSX</span>
<span class="hljs-keyword">import</span> { createElement <span class="hljs-keyword">as</span> h } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>

const Button = (props) =&gt; (
  &lt;button {...props} /&gt;
)
export default Button</pre><p>At this point, the only difference in these components across libraries is the <code>import</code> statement.
Using a module bundler like webpack, even this can be abstracted out of the component module.</p>
<p>Using webpack’s ProvidePlugin, the create element function can be exposed to all modules.
This does involve having a variable in the global scope, but I think the trade-off might be worth it in some cases.</p>
<pre><span class="hljs-comment">// Custom create-element module</span>
<span class="hljs-keyword">const</span> h = <span class="hljs-built_in">require</span>(<span class="hljs-string">'preact'</span>).h
<span class="hljs-built_in">module</span>.exports = h</pre><pre><span class="hljs-comment">// Example webpack configuration for Preact</span>
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
<span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack'</span>)

<span class="hljs-built_in">module</span>.exports = {
  ...,
  plugins: [
    <span class="hljs-keyword">new</span> webpack.ProvidePlugin([
      h: path.resolve(<span class="hljs-string">'./preact-create-element'</span>)
    ])
  ]
}</pre><p>To avoid variable collisions, the function could be named anything (e.g. <code>__h</code>) as long as the <code>.babelrc</code> pragma matches.</p>
<p>In addition to the name of the create element function, there are some slight differences in the naming conventions
for HTML attributes (e.g. <code>htmlFor</code> and <code>className</code>) and handling child elements.
Transforming these props could be handled in the custom function, but the implementation details have been left out of this post.</p>
<p>With this configuration, the Button component can now be written like this:</p>
<pre><span class="hljs-keyword">const</span> Button = (props) =&gt; (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">button</span> {<span class="hljs-attribute">...props</span>} /&gt;</span>
)</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Button</pre><p>I’ve put up a rough demonstration of this concept, with the same two UI components being rendered to the DOM by
React, Preact, hyperscript, and bel here: <a href="http://jxnblk.com/universal-components">Universal Components</a>.</p>
<p>With a little bit of configuration, a whole library of UI components could be written in a manner that would allow
the DOM rendering library to be swapped out at some point in the future,
without the need to use a tool like <a href="https://github.com/facebook/codemod">Codemod</a>.
There’s probably even a way to wrap components in an open-source library like <a href="http://jxnblk.com/rebass">Rebass</a>
to make them compatible with more than one functional DOM rendering library as well.</p>
</div><noscript></noscript><div class="inline-block"><a href="https://twitter.com/share" class="twitter-share-button" data-text="Universal UI Components" data-via="jxnblk" data-size="large">Tweet</a><script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?"http":"https";if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document, "script", "twitter-wjs");</script></div><p>Questions, Comments, Suggestions? <a href="https://github.com/jxnblk/writing/issues/new?title=Universal UI Components" target="_blank">Open an Issue</a></p><div class="py3"><h4 class="m0">Related</h4><ul class="list-reset m0"><li><a href="http://jxnblk.com/writing/posts/components" class="break-word">Components</a></li><li><a href="http://jxnblk.com/universal-components" class="break-word">Universal Components</a></li><li><a href="http://jxnblk.com/rebass" class="break-word">Rebass</a></li><li><a href="http://jxnblk.com/cxs" class="break-word">cxs</a></li><li><a href="http://jxnblk.com/react-cxs" class="break-word">React-cxs</a></li><li><a href="http://jxnblk.com/hyp" class="break-word">hyp</a></li></ul></div></div><footer class="sc py4"><a href="/">Made by Jxnblk</a></footer><script>(function(i,s,o,g,r,a,m){i["GoogleAnalyticsObject"]=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,"script","//www.google-analytics.com/analytics.js","ga"); ga("create", "UA-4603832-6", "auto"); ga("send", "pageview");</script></body></html>